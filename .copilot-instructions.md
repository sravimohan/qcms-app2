# GitHub Copilot Instructions for QCMS

## Project Context

You are working on QCMS (Questionaire Content Management System), a monorepo with:

- qcms-app: Main Next.js application
- qcms-form: Form builder application
- ui: Shared React Aria component library

## Quick Reference

- **Framework**: Next.js 15.5.3 with App Router
- **Language**: TypeScript 5.9.2 (strict mode)
- **UI Library**: React Aria Components 1.12.2
- **Styling**: Tailwind CSS 4.1.13
- **Code Quality**: Biome 2.2.4 (not ESLint/Prettier)
- **Package Manager**: pnpm (not npm/yarn)

## Code Generation Guidelines

### Component Structure

```typescript
import { type ComponentProps } from "react";
import { Button } from "react-aria-components";
import { clsx } from "clsx";

interface MyComponentProps extends ComponentProps<"div"> {
  variant?: "primary" | "secondary";
}

export default function MyComponent({
  variant = "primary",
  className,
  ...props
}: MyComponentProps) {
  return (
    <div
      className={clsx(
        "base-styles",
        variant === "primary" && "primary-styles",
        className
      )}
      {...props}
    />
  );
}
```

### Import Patterns

```typescript
// External libraries first
import { useState } from "react";
import { Button } from "react-aria-components";
import { clsx } from "clsx";

// Internal imports with @/ alias
import { Header } from "@/components/Header";
import { utils } from "@/utils/styles";

// Relative imports last
import "./styles.css";
```

### Styling Approach

- Use Tailwind utility classes
- Leverage `clsx` for conditional classes
- Use `tailwind-merge` when combining classes
- Follow mobile-first responsive design
- Maintain accessibility with proper ARIA labels
- never use specific tailwind classes like `bg-blue-500` directly; always use semantic or variant-based classes defined in your design system.

### File Naming

- Components: PascalCase (`UserMenu.tsx`)
- Pages: lowercase folders (`dashboard/`, `settings/`)
- Utilities: camelCase (`formatDate.ts`)

## Accessibility Requirements

- All interactive elements need proper ARIA labels
- Support keyboard navigation
- Use semantic HTML elements
- Maintain WCAG 2.1 AA compliance
- Test with screen readers

## Performance Best Practices

- Use React.memo for expensive components
- Prefer server components when possible
- Use dynamic imports for code splitting
- Optimize images with Next.js Image component
- Implement proper loading states

## Common Patterns

- Error boundaries for error handling
- Consistent loading states
- Form validation with proper feedback
- Theme-aware components
- Responsive design with Tailwind breakpoints

## What NOT to do

- Don't use ESLint/Prettier configs (use Biome)
- Don't use npm/yarn commands (use pnpm)
- Don't ignore accessibility requirements
- Don't create new patterns without checking existing ones
- Don't use inline styles (use Tailwind classes)

## When in doubt

- Check existing components in /components
- Follow React Aria Components documentation
- Maintain TypeScript strict compliance
- Ensure mobile responsiveness
- Test accessibility with keyboard navigation
